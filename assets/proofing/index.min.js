(self["webpackChunkArise"] = self["webpackChunkArise"] || []).push([ [ "proofing" ], {
    "./src/assets/proofing/main.js": () => {
        "use strict";
    },
    "../shared/browser/utils/sentry.js": (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__("../shared/node_modules/core-js/modules/es.regexp.exec.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.string.split.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.date.to-string.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.to-string.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.regexp.to-string.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.includes.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.string.includes.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.number.constructor.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.number.is-nan.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.concat.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.iterator.js");
        __webpack_require__("../shared/node_modules/core-js/modules/web.dom-collections.iterator.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.find.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.string.match.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.define-property.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.keys.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.symbol.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.filter.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.array.for-each.js");
        __webpack_require__("../shared/node_modules/core-js/modules/web.dom-collections.for-each.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
        __webpack_require__("../shared/node_modules/core-js/modules/es.object.define-properties.js");
        var esm = __webpack_require__("../shared/node_modules/@sentry/browser/esm/index.js");
        var sdk = __webpack_require__("../shared/node_modules/@sentry/browser/esm/sdk.js");
        var minimal_esm = __webpack_require__("../shared/node_modules/@sentry/minimal/esm/index.js");
        var hubextensions = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/hubextensions.js");
        var tslib_es6 = __webpack_require__("../shared/node_modules/tslib/tslib.es6.js");
        var env = __webpack_require__("../shared/node_modules/@sentry/utils/esm/env.js");
        var logger = __webpack_require__("../shared/node_modules/@sentry/utils/esm/logger.js");
        var global = __webpack_require__("../shared/node_modules/@sentry/utils/esm/global.js");
        var idletransaction = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/idletransaction.js");
        var utils = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/utils.js");
        var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*" + "([0-9a-f]{32})?" + "-?([0-9a-f]{16})?" + "-?([01])?" + "[ \\t]*$");
        function extractTraceparentData(traceparent) {
            var matches = traceparent.match(TRACEPARENT_REGEXP);
            if (matches) {
                var parentSampled = void 0;
                if ("1" === matches[3]) parentSampled = true; else if ("0" === matches[3]) parentSampled = false;
                return {
                    traceId: matches[1],
                    parentSampled,
                    parentSpanId: matches[2]
                };
            }
            return;
        }
        var constants = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/constants.js");
        var backgroundtab_global = (0, global.getGlobalObject)();
        function registerBackgroundTabDetection() {
            if (backgroundtab_global && backgroundtab_global.document) backgroundtab_global.document.addEventListener("visibilitychange", (function() {
                var activeTransaction = (0, utils.getActiveTransaction)();
                if (backgroundtab_global.document.hidden && activeTransaction) {
                    var statusType = "cancelled";
                    (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
                    if (!activeTransaction.status) activeTransaction.setStatus(statusType);
                    activeTransaction.setTag("visibilitychange", "document.hidden");
                    activeTransaction.setTag(constants.FINISH_REASON_TAG, constants.IDLE_TRANSACTION_FINISH_REASONS[2]);
                    activeTransaction.finish();
                }
            })); else (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
        }
        var node = __webpack_require__("../shared/node_modules/@sentry/utils/esm/node.js");
        var time = __webpack_require__("../shared/node_modules/@sentry/utils/esm/time.js");
        var browser = __webpack_require__("../shared/node_modules/@sentry/utils/esm/browser.js");
        var bindReporter = function(callback, metric, reportAllChanges) {
            var prevValue;
            return function(forceReport) {
                if (metric.value >= 0) if (forceReport || reportAllChanges) {
                    metric.delta = metric.value - (prevValue || 0);
                    if (metric.delta || void 0 === prevValue) {
                        prevValue = metric.value;
                        callback(metric);
                    }
                }
            };
        };
        var generateUniqueID = function() {
            return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
        };
        var initMetric = function(name, value) {
            return {
                name,
                value: null !== value && void 0 !== value ? value : -1,
                delta: 0,
                entries: [],
                id: generateUniqueID()
            };
        };
        var observe = function(type, callback) {
            try {
                if (PerformanceObserver.supportedEntryTypes.includes(type)) {
                    if ("first-input" === type && !("PerformanceEventTiming" in self)) return;
                    var po = new PerformanceObserver((function(l) {
                        return l.getEntries().map(callback);
                    }));
                    po.observe({
                        type,
                        buffered: true
                    });
                    return po;
                }
            } catch (e) {}
            return;
        };
        var onHidden = function(cb, once) {
            var onHiddenOrPageHide = function(event) {
                if ("pagehide" === event.type || "hidden" === (0, global.getGlobalObject)().document.visibilityState) {
                    cb(event);
                    if (once) {
                        removeEventListener("visibilitychange", onHiddenOrPageHide, true);
                        removeEventListener("pagehide", onHiddenOrPageHide, true);
                    }
                }
            };
            addEventListener("visibilitychange", onHiddenOrPageHide, true);
            addEventListener("pagehide", onHiddenOrPageHide, true);
        };
        var getCLS = function(onReport, reportAllChanges) {
            var metric = initMetric("CLS", 0);
            var report;
            var sessionValue = 0;
            var sessionEntries = [];
            var entryHandler = function(entry) {
                if (entry && !entry.hadRecentInput) {
                    var firstSessionEntry = sessionEntries[0];
                    var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
                    if (sessionValue && 0 !== sessionEntries.length && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
                        sessionValue += entry.value;
                        sessionEntries.push(entry);
                    } else {
                        sessionValue = entry.value;
                        sessionEntries = [ entry ];
                    }
                    if (sessionValue > metric.value) {
                        metric.value = sessionValue;
                        metric.entries = sessionEntries;
                        if (report) report();
                    }
                }
            };
            var po = observe("layout-shift", entryHandler);
            if (po) {
                report = bindReporter(onReport, metric, reportAllChanges);
                onHidden((function() {
                    po.takeRecords().map(entryHandler);
                    report(true);
                }));
            }
        };
        var firstHiddenTime = -1;
        var initHiddenTime = function() {
            return "hidden" === (0, global.getGlobalObject)().document.visibilityState ? 0 : 1 / 0;
        };
        var trackChanges = function() {
            onHidden((function(_a) {
                var timeStamp = _a.timeStamp;
                firstHiddenTime = timeStamp;
            }), true);
        };
        var getVisibilityWatcher = function() {
            if (firstHiddenTime < 0) {
                firstHiddenTime = initHiddenTime();
                trackChanges();
            }
            return {
                get firstHiddenTime() {
                    return firstHiddenTime;
                }
            };
        };
        var getFID = function(onReport, reportAllChanges) {
            var visibilityWatcher = getVisibilityWatcher();
            var metric = initMetric("FID");
            var report;
            var entryHandler = function(entry) {
                if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
                    metric.value = entry.processingStart - entry.startTime;
                    metric.entries.push(entry);
                    report(true);
                }
            };
            var po = observe("first-input", entryHandler);
            if (po) {
                report = bindReporter(onReport, metric, reportAllChanges);
                onHidden((function() {
                    po.takeRecords().map(entryHandler);
                    po.disconnect();
                }), true);
            }
        };
        var reportedMetricIDs = {};
        var getLCP = function(onReport, reportAllChanges) {
            var visibilityWatcher = getVisibilityWatcher();
            var metric = initMetric("LCP");
            var report;
            var entryHandler = function(entry) {
                var value = entry.startTime;
                if (value < visibilityWatcher.firstHiddenTime) {
                    metric.value = value;
                    metric.entries.push(entry);
                }
                if (report) report();
            };
            var po = observe("largest-contentful-paint", entryHandler);
            if (po) {
                report = bindReporter(onReport, metric, reportAllChanges);
                var stopListening_1 = function() {
                    if (!reportedMetricIDs[metric.id]) {
                        po.takeRecords().map(entryHandler);
                        po.disconnect();
                        reportedMetricIDs[metric.id] = true;
                        report(true);
                    }
                };
                [ "keydown", "click" ].forEach((function(type) {
                    addEventListener(type, stopListening_1, {
                        once: true,
                        capture: true
                    });
                }));
                onHidden(stopListening_1, true);
            }
        };
        var metrics_global = (0, global.getGlobalObject)();
        var MetricsInstrumentation = function() {
            function MetricsInstrumentation(_reportAllChanges) {
                if (void 0 === _reportAllChanges) _reportAllChanges = false;
                this._reportAllChanges = _reportAllChanges;
                this._measurements = {};
                this._performanceCursor = 0;
                if (!(0, node.isNodeEnv)() && metrics_global && metrics_global.performance && metrics_global.document) {
                    if (metrics_global.performance.mark) metrics_global.performance.mark("sentry-tracing-init");
                    this._trackCLS();
                    this._trackLCP();
                    this._trackFID();
                }
            }
            MetricsInstrumentation.prototype.addPerformanceEntries = function(transaction) {
                var _this = this;
                if (!metrics_global || !metrics_global.performance || !metrics_global.performance.getEntries || !time.browserPerformanceTimeOrigin) return;
                (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Adding & adjusting spans using Performance API");
                var timeOrigin = (0, utils.msToSec)(time.browserPerformanceTimeOrigin);
                var responseStartTimestamp;
                var requestStartTimestamp;
                metrics_global.performance.getEntries().slice(this._performanceCursor).forEach((function(entry) {
                    var startTime = (0, utils.msToSec)(entry.startTime);
                    var duration = (0, utils.msToSec)(entry.duration);
                    if ("navigation" === transaction.op && timeOrigin + startTime < transaction.startTimestamp) return;
                    switch (entry.entryType) {
                      case "navigation":
                        addNavigationSpans(transaction, entry, timeOrigin);
                        responseStartTimestamp = timeOrigin + (0, utils.msToSec)(entry.responseStart);
                        requestStartTimestamp = timeOrigin + (0, utils.msToSec)(entry.requestStart);
                        break;

                      case "mark":
                      case "paint":
                      case "measure":
                        var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                        var firstHidden = getVisibilityWatcher();
                        var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
                        if ("first-paint" === entry.name && shouldRecord) {
                            (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding FP");
                            _this._measurements["fp"] = {
                                value: entry.startTime
                            };
                            _this._measurements["mark.fp"] = {
                                value: startTimestamp
                            };
                        }
                        if ("first-contentful-paint" === entry.name && shouldRecord) {
                            (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding FCP");
                            _this._measurements["fcp"] = {
                                value: entry.startTime
                            };
                            _this._measurements["mark.fcp"] = {
                                value: startTimestamp
                            };
                        }
                        break;

                      case "resource":
                        var resourceName = entry.name.replace(metrics_global.location.origin, "");
                        addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                    }
                }));
                this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
                this._trackNavigator(transaction);
                if ("pageload" === transaction.op) {
                    var timeOrigin_1 = (0, utils.msToSec)(time.browserPerformanceTimeOrigin);
                    if ("number" === typeof responseStartTimestamp) {
                        (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding TTFB");
                        this._measurements["ttfb"] = {
                            value: 1e3 * (responseStartTimestamp - transaction.startTimestamp)
                        };
                        if ("number" === typeof requestStartTimestamp && requestStartTimestamp <= responseStartTimestamp) this._measurements["ttfb.requestTime"] = {
                            value: 1e3 * (responseStartTimestamp - requestStartTimestamp)
                        };
                    }
                    [ "fcp", "fp", "lcp" ].forEach((function(name) {
                        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) return;
                        var oldValue = _this._measurements[name].value;
                        var measurementTimestamp = timeOrigin_1 + (0, utils.msToSec)(oldValue);
                        var normalizedValue = Math.abs(1e3 * (measurementTimestamp - transaction.startTimestamp));
                        var delta = normalizedValue - oldValue;
                        (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
                        _this._measurements[name].value = normalizedValue;
                    }));
                    if (this._measurements["mark.fid"] && this._measurements["fid"]) _startChild(transaction, {
                        description: "first input delay",
                        endTimestamp: this._measurements["mark.fid"].value + (0, utils.msToSec)(this._measurements["fid"].value),
                        op: "web.vitals",
                        startTimestamp: this._measurements["mark.fid"].value
                    });
                    if (!("fcp" in this._measurements)) delete this._measurements.cls;
                    transaction.setMeasurements(this._measurements);
                    tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
                    transaction.setTag("sentry_reportAllChanges", this._reportAllChanges);
                }
            };
            MetricsInstrumentation.prototype._trackNavigator = function(transaction) {
                var navigator = metrics_global.navigator;
                if (!navigator) return;
                var connection = navigator.connection;
                if (connection) {
                    if (connection.effectiveType) transaction.setTag("effectiveConnectionType", connection.effectiveType);
                    if (connection.type) transaction.setTag("connectionType", connection.type);
                    if (isMeasurementValue(connection.rtt)) this._measurements["connection.rtt"] = {
                        value: connection.rtt
                    };
                    if (isMeasurementValue(connection.downlink)) this._measurements["connection.downlink"] = {
                        value: connection.downlink
                    };
                }
                if (isMeasurementValue(navigator.deviceMemory)) transaction.setTag("deviceMemory", String(navigator.deviceMemory));
                if (isMeasurementValue(navigator.hardwareConcurrency)) transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
            };
            MetricsInstrumentation.prototype._trackCLS = function() {
                var _this = this;
                getCLS((function(metric) {
                    var entry = metric.entries.pop();
                    if (!entry) return;
                    (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding CLS");
                    _this._measurements["cls"] = {
                        value: metric.value
                    };
                    _this._clsEntry = entry;
                }));
            };
            MetricsInstrumentation.prototype._trackLCP = function() {
                var _this = this;
                getLCP((function(metric) {
                    var entry = metric.entries.pop();
                    if (!entry) return;
                    var timeOrigin = (0, utils.msToSec)(time.browserPerformanceTimeOrigin);
                    var startTime = (0, utils.msToSec)(entry.startTime);
                    (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding LCP");
                    _this._measurements["lcp"] = {
                        value: metric.value
                    };
                    _this._measurements["mark.lcp"] = {
                        value: timeOrigin + startTime
                    };
                    _this._lcpEntry = entry;
                }), this._reportAllChanges);
            };
            MetricsInstrumentation.prototype._trackFID = function() {
                var _this = this;
                getFID((function(metric) {
                    var entry = metric.entries.pop();
                    if (!entry) return;
                    var timeOrigin = (0, utils.msToSec)(time.browserPerformanceTimeOrigin);
                    var startTime = (0, utils.msToSec)(entry.startTime);
                    (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding FID");
                    _this._measurements["fid"] = {
                        value: metric.value
                    };
                    _this._measurements["mark.fid"] = {
                        value: timeOrigin + startTime
                    };
                }));
            };
            return MetricsInstrumentation;
        }();
        function addNavigationSpans(transaction, entry, timeOrigin) {
            [ "unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect" ].forEach((function(event) {
                addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
            }));
            addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
            addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
            addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
            addRequest(transaction, entry, timeOrigin);
        }
        function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
            var measureStartTimestamp = timeOrigin + startTime;
            var measureEndTimestamp = measureStartTimestamp + duration;
            _startChild(transaction, {
                description: entry.name,
                endTimestamp: measureEndTimestamp,
                op: entry.entryType,
                startTimestamp: measureStartTimestamp
            });
            return measureStartTimestamp;
        }
        function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
            if ("xmlhttprequest" === entry.initiatorType || "fetch" === entry.initiatorType) return;
            var data = {};
            if ("transferSize" in entry) data["Transfer Size"] = entry.transferSize;
            if ("encodedBodySize" in entry) data["Encoded Body Size"] = entry.encodedBodySize;
            if ("decodedBodySize" in entry) data["Decoded Body Size"] = entry.decodedBodySize;
            var startTimestamp = timeOrigin + startTime;
            var endTimestamp = startTimestamp + duration;
            _startChild(transaction, {
                description: resourceName,
                endTimestamp,
                op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
                startTimestamp,
                data
            });
        }
        function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
            var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
            var start = entry[event + "Start"];
            if (!start || !end) return;
            _startChild(transaction, {
                op: "browser",
                description: null !== description && void 0 !== description ? description : event,
                startTimestamp: timeOrigin + (0, utils.msToSec)(start),
                endTimestamp: timeOrigin + (0, utils.msToSec)(end)
            });
        }
        function addRequest(transaction, entry, timeOrigin) {
            _startChild(transaction, {
                op: "browser",
                description: "request",
                startTimestamp: timeOrigin + (0, utils.msToSec)(entry.requestStart),
                endTimestamp: timeOrigin + (0, utils.msToSec)(entry.responseEnd)
            });
            _startChild(transaction, {
                op: "browser",
                description: "response",
                startTimestamp: timeOrigin + (0, utils.msToSec)(entry.responseStart),
                endTimestamp: timeOrigin + (0, utils.msToSec)(entry.responseEnd)
            });
        }
        function _startChild(transaction, _a) {
            var startTimestamp = _a.startTimestamp, ctx = (0, tslib_es6.__rest)(_a, [ "startTimestamp" ]);
            if (startTimestamp && transaction.startTimestamp > startTimestamp) transaction.startTimestamp = startTimestamp;
            return transaction.startChild((0, tslib_es6.__assign)({
                startTimestamp
            }, ctx));
        }
        function isMeasurementValue(value) {
            return "number" === typeof value && isFinite(value);
        }
        function tagMetricInfo(transaction, lcpEntry, clsEntry) {
            if (lcpEntry) {
                (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding LCP Data");
                if (lcpEntry.element) transaction.setTag("lcp.element", (0, browser.htmlTreeAsString)(lcpEntry.element));
                if (lcpEntry.id) transaction.setTag("lcp.id", lcpEntry.id);
                if (lcpEntry.url) transaction.setTag("lcp.url", lcpEntry.url.trim().slice(0, 200));
                transaction.setTag("lcp.size", lcpEntry.size);
            }
            if (clsEntry && clsEntry.sources) {
                (0, env.isDebugBuild)() && logger.logger.log("[Measurements] Adding CLS Data");
                clsEntry.sources.forEach((function(source, index) {
                    return transaction.setTag("cls.source." + (index + 1), (0, browser.htmlTreeAsString)(source.node));
                }));
            }
        }
        var string = __webpack_require__("../shared/node_modules/@sentry/utils/esm/string.js");
        var instrument = __webpack_require__("../shared/node_modules/@sentry/utils/esm/instrument.js");
        var is = __webpack_require__("../shared/node_modules/@sentry/utils/esm/is.js");
        var DEFAULT_TRACING_ORIGINS = [ "localhost", /^\// ];
        var defaultRequestInstrumentationOptions = {
            traceFetch: true,
            traceXHR: true,
            tracingOrigins: DEFAULT_TRACING_ORIGINS
        };
        function instrumentOutgoingRequests(_options) {
            var _a = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
            var urlMap = {};
            var defaultShouldCreateSpan = function(url) {
                if (urlMap[url]) return urlMap[url];
                var origins = tracingOrigins;
                urlMap[url] = origins.some((function(origin) {
                    return (0, string.isMatchingPattern)(url, origin);
                })) && !(0, string.isMatchingPattern)(url, "sentry_key");
                return urlMap[url];
            };
            var shouldCreateSpan = defaultShouldCreateSpan;
            if ("function" === typeof shouldCreateSpanForRequest) shouldCreateSpan = function(url) {
                return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
            };
            var spans = {};
            if (traceFetch) (0, instrument.addInstrumentationHandler)("fetch", (function(handlerData) {
                fetchCallback(handlerData, shouldCreateSpan, spans);
            }));
            if (traceXHR) (0, instrument.addInstrumentationHandler)("xhr", (function(handlerData) {
                xhrCallback(handlerData, shouldCreateSpan, spans);
            }));
        }
        function fetchCallback(handlerData, shouldCreateSpan, spans) {
            if (!(0, utils.hasTracingEnabled)() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) return;
            if (handlerData.endTimestamp) {
                var spanId = handlerData.fetchData.__span;
                if (!spanId) return;
                var span = spans[spanId];
                if (span) {
                    if (handlerData.response) span.setHttpStatus(handlerData.response.status); else if (handlerData.error) span.setStatus("internal_error");
                    span.finish();
                    delete spans[spanId];
                }
                return;
            }
            var activeTransaction = (0, utils.getActiveTransaction)();
            if (activeTransaction) {
                span = activeTransaction.startChild({
                    data: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, handlerData.fetchData), {
                        type: "fetch"
                    }),
                    description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
                    op: "http.client"
                });
                handlerData.fetchData.__span = span.spanId;
                spans[span.spanId] = span;
                var request = handlerData.args[0] = handlerData.args[0];
                var options = handlerData.args[1] = handlerData.args[1] || {};
                var headers = options.headers;
                if ((0, is.isInstanceOf)(request, Request)) headers = request.headers;
                if (headers) if ("function" === typeof headers.append) headers.append("sentry-trace", span.toTraceparent()); else if (Array.isArray(headers)) headers = (0, 
                tslib_es6.__spread)(headers, [ [ "sentry-trace", span.toTraceparent() ] ]); else headers = (0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, headers), {
                    "sentry-trace": span.toTraceparent()
                }); else headers = {
                    "sentry-trace": span.toTraceparent()
                };
                options.headers = headers;
            }
        }
        function xhrCallback(handlerData, shouldCreateSpan, spans) {
            if (!(0, utils.hasTracingEnabled)() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) return;
            var xhr = handlerData.xhr.__sentry_xhr__;
            if (handlerData.endTimestamp) {
                var spanId = handlerData.xhr.__sentry_xhr_span_id__;
                if (!spanId) return;
                var span = spans[spanId];
                if (span) {
                    span.setHttpStatus(xhr.status_code);
                    span.finish();
                    delete spans[spanId];
                }
                return;
            }
            var activeTransaction = (0, utils.getActiveTransaction)();
            if (activeTransaction) {
                span = activeTransaction.startChild({
                    data: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, xhr.data), {
                        type: "xhr",
                        method: xhr.method,
                        url: xhr.url
                    }),
                    description: xhr.method + " " + xhr.url,
                    op: "http.client"
                });
                handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
                spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
                if (handlerData.xhr.setRequestHeader) try {
                    handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
                } catch (_) {}
            }
        }
        var router_global = (0, global.getGlobalObject)();
        function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
            if (void 0 === startTransactionOnPageLoad) startTransactionOnPageLoad = true;
            if (void 0 === startTransactionOnLocationChange) startTransactionOnLocationChange = true;
            if (!router_global || !router_global.location) {
                (0, env.isDebugBuild)() && logger.logger.warn("Could not initialize routing instrumentation due to invalid location");
                return;
            }
            var startingUrl = router_global.location.href;
            var activeTransaction;
            if (startTransactionOnPageLoad) activeTransaction = customStartTransaction({
                name: router_global.location.pathname,
                op: "pageload"
            });
            if (startTransactionOnLocationChange) (0, instrument.addInstrumentationHandler)("history", (function(_a) {
                var to = _a.to, from = _a.from;
                if (void 0 === from && startingUrl && -1 !== startingUrl.indexOf(to)) {
                    startingUrl = void 0;
                    return;
                }
                if (from !== to) {
                    startingUrl = void 0;
                    if (activeTransaction) {
                        (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
                        activeTransaction.finish();
                    }
                    activeTransaction = customStartTransaction({
                        name: router_global.location.pathname,
                        op: "navigation"
                    });
                }
            }));
        }
        var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
        var DEFAULT_BROWSER_TRACING_OPTIONS = (0, tslib_es6.__assign)({
            idleTimeout: idletransaction.DEFAULT_IDLE_TIMEOUT,
            markBackgroundTransactions: true,
            maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS,
            routingInstrumentation: instrumentRoutingWithDefaults,
            startTransactionOnLocationChange: true,
            startTransactionOnPageLoad: true
        }, defaultRequestInstrumentationOptions);
        var BrowserTracing = function() {
            function BrowserTracing(_options) {
                this.name = BrowserTracing.id;
                this._configuredIdleTimeout = void 0;
                var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
                if (_options) {
                    this._configuredIdleTimeout = _options.idleTimeout;
                    if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && 0 !== _options.tracingOrigins.length) tracingOrigins = _options.tracingOrigins; else (0, 
                    env.isDebugBuild)() && (this._emitOptionsWarning = true);
                }
                this.options = (0, tslib_es6.__assign)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), {
                    tracingOrigins
                });
                var _metricOptions = this.options._metricOptions;
                this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
            }
            BrowserTracing.prototype.setupOnce = function(_, getCurrentHub) {
                var _this = this;
                this._getCurrentHub = getCurrentHub;
                if (this._emitOptionsWarning) {
                    (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
                    (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
                }
                var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
                instrumentRouting((function(context) {
                    return _this._createRouteTransaction(context);
                }), startTransactionOnPageLoad, startTransactionOnLocationChange);
                if (markBackgroundTransactions) registerBackgroundTabDetection();
                instrumentOutgoingRequests({
                    traceFetch,
                    traceXHR,
                    tracingOrigins,
                    shouldCreateSpanForRequest
                });
            };
            BrowserTracing.prototype._createRouteTransaction = function(context) {
                var _this = this;
                if (!this._getCurrentHub) {
                    (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
                    return;
                }
                var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
                var parentContextFromHeader = "pageload" === context.op ? getHeaderContext() : void 0;
                var expandedContext = (0, tslib_es6.__assign)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, context), parentContextFromHeader), {
                    trimEnd: true
                });
                var modifiedContext = "function" === typeof beforeNavigate ? beforeNavigate(expandedContext) : expandedContext;
                var finalContext = void 0 === modifiedContext ? (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, expandedContext), {
                    sampled: false
                }) : modifiedContext;
                if (false === finalContext.sampled) (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
                (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
                var hub = this._getCurrentHub();
                var location = (0, global.getGlobalObject)().location;
                var idleTransaction = (0, hubextensions.startIdleTransaction)(hub, finalContext, idleTimeout, true, {
                    location
                });
                idleTransaction.registerBeforeFinishCallback((function(transaction, endTimestamp) {
                    _this._metrics.addPerformanceEntries(transaction);
                    adjustTransactionDuration((0, utils.secToMs)(maxTransactionDuration), transaction, endTimestamp);
                }));
                idleTransaction.setTag("idleTimeout", this._configuredIdleTimeout);
                return idleTransaction;
            };
            BrowserTracing.id = "BrowserTracing";
            return BrowserTracing;
        }();
        function getHeaderContext() {
            var header = getMetaContent("sentry-trace");
            if (header) return extractTraceparentData(header);
            return;
        }
        function getMetaContent(metaName) {
            var el = (0, global.getGlobalObject)().document.querySelector("meta[name=" + metaName + "]");
            return el ? el.getAttribute("content") : null;
        }
        function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
            var diff = endTimestamp - transaction.startTimestamp;
            var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
            if (isOutdatedTransaction) {
                transaction.setStatus("deadline_exceeded");
                transaction.setTag("maxTransactionDurationExceeded", "true");
            }
        }
        (0, hubextensions.addExtensionMethods)();
        var get_env = __webpack_require__("../shared/browser/utils/get-env.js");
        function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                }));
                keys.push.apply(keys, symbols);
            }
            return keys;
        }
        function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = null != arguments[i] ? arguments[i] : {};
                if (i % 2) ownKeys(Object(source), true).forEach((function(key) {
                    _defineProperty(target, key, source[key]);
                })); else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); else ownKeys(Object(source)).forEach((function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                }));
            }
            return target;
        }
        function _defineProperty(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
            }); else obj[key] = value;
            return obj;
        }
        var errorTypesEnum = {
            CUSTOM_CODES: "CUSTOM_CODES"
        };
        var errorPositionEnum = {
            TOP: "top",
            BOTTOM: "bottom"
        };
        function getErrorLine(error) {
            if (!(null !== error && void 0 !== error && error.stack)) return;
            var stack = error.stack.toString().split(/\r\n|\n/);
            var frameRE = /:(\d+):(?:\d+)[^\d]*$/;
            var firstTrace;
            var frame;
            do {
                frame = stack.shift();
                firstTrace = frameRE.exec(frame);
                if (!frame) break;
            } while (!frameRE.exec(frame) || frame.includes("at <anonymous>") || 1 === +(firstTrace && firstTrace[1]));
            var causeTrace = +(firstTrace && firstTrace[1] || "0");
            return causeTrace;
        }
        function setEventErrorInfo(event, position) {
            if (!event.contexts) event.contexts = {};
            event.contexts.error_info = {
                position,
                error_type: errorTypesEnum.CUSTOM_CODES
            };
        }
        try {
            var _window$Shopline, _window$Shopline$even;
            var _getEnv = (0, get_env["default"])(), APP_ENV = _getEnv.APP_ENV, SENTRY_TRACES_SAMPLE_RATE = _getEnv.SENTRY_TRACES_SAMPLE_RATE;
            var sampleRate = Number(SENTRY_TRACES_SAMPLE_RATE);
            if (Number.isNaN(sampleRate)) sampleRate = 0;
            var options = {
                debug: false,
                environment: APP_ENV,
                release: "".concat(APP_ENV, "@").concat("undefined_theme_Arise_1.0.0_e11a14d02"),
                dsn: (0, get_env["default"])(void 0 || "SENTRY_DSN") || "",
                autoSessionTracking: false,
                ignoreErrors: [ "ReportingObserver [deprecation]" ],
                blacklistUrls: [ /^localhost/, /extensions\//i, /^chrome:\/\//i, /^chrome-extensions:\/\//i, /^safari-extension:\/\//i, /^file:\/\//i ],
                tracesSampleRate: sampleRate,
                integrations: [ new BrowserTracing ],
                beforeSend: function(event, hint) {
                    var _event$exception, _event$exception$valu, _event$exception$valu2, _traceFrames$, _traceFrames$find, _traceFrames$2;
                    var error = hint.originalException;
                    var traceFrames = (null === event || void 0 === event ? void 0 : null === (_event$exception = event.exception) || void 0 === _event$exception ? void 0 : null === (_event$exception$valu = _event$exception.values[0]) || void 0 === _event$exception$valu ? void 0 : null === (_event$exception$valu2 = _event$exception$valu.stacktrace) || void 0 === _event$exception$valu2 ? void 0 : _event$exception$valu2.frames) || [];
                    var errorLine = getErrorLine(error) || (null === (_traceFrames$ = traceFrames[0]) || void 0 === _traceFrames$ ? void 0 : _traceFrames$.lineno);
                    var errorFile = (null === (_traceFrames$find = traceFrames.find((function(frame) {
                        return frame.lineno === errorLine;
                    }))) || void 0 === _traceFrames$find ? void 0 : _traceFrames$find.filename) || (null === (_traceFrames$2 = traceFrames[0]) || void 0 === _traceFrames$2 ? void 0 : _traceFrames$2.filename);
                    if (errorFile === window.location.href) {
                        if ("undefined" !== typeof window.__CUSTOM_HEADER_START__ && "undefined" !== typeof window.__CUSTOM_HEADER_END__) {
                            var isHeadError = errorLine >= +window.__CUSTOM_HEADER_START__ && errorLine <= +window.__CUSTOM_HEADER_END__;
                            if (isHeadError) setEventErrorInfo(event, errorPositionEnum.TOP);
                        }
                        if ("undefined" !== typeof window.__CUSTOM_FOOTER_START__) {
                            var isFootError = errorLine >= +window.__CUSTOM_FOOTER_START__ && ("undefined" !== typeof window.__CUSTOM_FOOTER_END__ ? errorLine <= +window.__CUSTOM_FOOTER_END__ : true);
                            if (isFootError) setEventErrorInfo(event, errorPositionEnum.BOTTOM);
                        }
                    }
                    return event;
                },
                beforeBreadcrumb: function(breadcrumb, hint) {
                    var _hint$xhr;
                    if ("xhr" === breadcrumb.category && null !== hint && void 0 !== hint && null !== (_hint$xhr = hint.xhr) && void 0 !== _hint$xhr && _hint$xhr.response) try {
                        var trace_id = hint.xhr.response.match(/trace_id":"(\S*?)"/)[1] || "";
                        return _objectSpread(_objectSpread({}, breadcrumb), {}, {
                            data: _objectSpread(_objectSpread({}, breadcrumb.data), {}, {
                                trace_id
                            })
                        });
                    } catch (err) {
                        return breadcrumb;
                    }
                    return breadcrumb;
                }
            };
            if (-1 === sampleRate) delete options.tracesSampleRate;
            sdk.init(options);
            null === (_window$Shopline = window.Shopline) || void 0 === _window$Shopline ? void 0 : null === (_window$Shopline$even = _window$Shopline.event) || void 0 === _window$Shopline$even ? void 0 : _window$Shopline$even.on("Sentry::CaptureMessage", (function() {
                minimal_esm.captureMessage.apply(esm, arguments);
            }));
        } catch (e) {
            console.error(e);
        }
    },
    "../shared/node_modules/@sentry/tracing/esm/constants.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            FINISH_REASON_TAG: () => FINISH_REASON_TAG,
            IDLE_TRANSACTION_FINISH_REASONS: () => IDLE_TRANSACTION_FINISH_REASONS
        });
        var FINISH_REASON_TAG = "finishReason";
        var IDLE_TRANSACTION_FINISH_REASONS = [ "heartbeatFailed", "idleTimeout", "documentHidden" ];
    },
    "../shared/node_modules/@sentry/tracing/esm/hubextensions.js": (module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            addExtensionMethods: () => addExtensionMethods,
            startIdleTransaction: () => startIdleTransaction
        });
        var tslib_es6 = __webpack_require__("../shared/node_modules/tslib/tslib.es6.js");
        var hub = __webpack_require__("../shared/node_modules/@sentry/hub/esm/hub.js");
        var env = __webpack_require__("../shared/node_modules/@sentry/utils/esm/env.js");
        var logger = __webpack_require__("../shared/node_modules/@sentry/utils/esm/logger.js");
        var node = __webpack_require__("../shared/node_modules/@sentry/utils/esm/node.js");
        var instrument = __webpack_require__("../shared/node_modules/@sentry/utils/esm/instrument.js");
        var utils = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/utils.js");
        function registerErrorInstrumentation() {
            (0, instrument.addInstrumentationHandler)("error", errorCallback);
            (0, instrument.addInstrumentationHandler)("unhandledrejection", errorCallback);
        }
        function errorCallback() {
            var activeTransaction = (0, utils.getActiveTransaction)();
            if (activeTransaction) {
                var status_1 = "internal_error";
                (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
                activeTransaction.setStatus(status_1);
            }
        }
        var idletransaction = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/idletransaction.js");
        var esm_transaction = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/transaction.js");
        module = __webpack_require__.hmd(module);
        function traceHeaders() {
            var scope = this.getScope();
            if (scope) {
                var span = scope.getSpan();
                if (span) return {
                    "sentry-trace": span.toTraceparent()
                };
            }
            return {};
        }
        function sample(transaction, options, samplingContext) {
            if (!(0, utils.hasTracingEnabled)(options)) {
                transaction.sampled = false;
                return transaction;
            }
            if (void 0 !== transaction.sampled) {
                transaction.setMetadata({
                    transactionSampling: {
                        method: "explicitly_set"
                    }
                });
                return transaction;
            }
            var sampleRate;
            if ("function" === typeof options.tracesSampler) {
                sampleRate = options.tracesSampler(samplingContext);
                transaction.setMetadata({
                    transactionSampling: {
                        method: "client_sampler",
                        rate: Number(sampleRate)
                    }
                });
            } else if (void 0 !== samplingContext.parentSampled) {
                sampleRate = samplingContext.parentSampled;
                transaction.setMetadata({
                    transactionSampling: {
                        method: "inheritance"
                    }
                });
            } else {
                sampleRate = options.tracesSampleRate;
                transaction.setMetadata({
                    transactionSampling: {
                        method: "client_rate",
                        rate: Number(sampleRate)
                    }
                });
            }
            if (!isValidSampleRate(sampleRate)) {
                (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
                transaction.sampled = false;
                return transaction;
            }
            if (!sampleRate) {
                (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Discarding transaction because " + ("function" === typeof options.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
                transaction.sampled = false;
                return transaction;
            }
            transaction.sampled = Math.random() < sampleRate;
            if (!transaction.sampled) {
                (0, env.isDebugBuild)() && logger.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
                return transaction;
            }
            (0, env.isDebugBuild)() && logger.logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
            return transaction;
        }
        function isValidSampleRate(rate) {
            if (isNaN(rate) || !("number" === typeof rate || "boolean" === typeof rate)) {
                (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
                return false;
            }
            if (rate < 0 || rate > 1) {
                (0, env.isDebugBuild)() && logger.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
                return false;
            }
            return true;
        }
        function _startTransaction(transactionContext, customSamplingContext) {
            var client = this.getClient();
            var options = client && client.getOptions() || {};
            var transaction = new esm_transaction.Transaction(transactionContext, this);
            transaction = sample(transaction, options, (0, tslib_es6.__assign)({
                parentSampled: transactionContext.parentSampled,
                transactionContext
            }, customSamplingContext));
            if (transaction.sampled) transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
            return transaction;
        }
        function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
            var client = hub.getClient();
            var options = client && client.getOptions() || {};
            var transaction = new idletransaction.IdleTransaction(transactionContext, hub, idleTimeout, onScope);
            transaction = sample(transaction, options, (0, tslib_es6.__assign)({
                parentSampled: transactionContext.parentSampled,
                transactionContext
            }, customSamplingContext));
            if (transaction.sampled) transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
            return transaction;
        }
        function _addTracingExtensions() {
            var carrier = (0, hub.getMainCarrier)();
            if (!carrier.__SENTRY__) return;
            carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
            if (!carrier.__SENTRY__.extensions.startTransaction) carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
            if (!carrier.__SENTRY__.extensions.traceHeaders) carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
        }
        function _autoloadDatabaseIntegrations() {
            var carrier = (0, hub.getMainCarrier)();
            if (!carrier.__SENTRY__) return;
            var packageToIntegrationMapping = {
                mongodb: function() {
                    var integration = (0, node.dynamicRequire)(module, "./integrations/node/mongo");
                    return new integration.Mongo;
                },
                mongoose: function() {
                    var integration = (0, node.dynamicRequire)(module, "./integrations/node/mongo");
                    return new integration.Mongo({
                        mongoose: true
                    });
                },
                mysql: function() {
                    var integration = (0, node.dynamicRequire)(module, "./integrations/node/mysql");
                    return new integration.Mysql;
                },
                pg: function() {
                    var integration = (0, node.dynamicRequire)(module, "./integrations/node/postgres");
                    return new integration.Postgres;
                }
            };
            var mappedPackages = Object.keys(packageToIntegrationMapping).filter((function(moduleName) {
                return !!(0, node.loadModule)(moduleName);
            })).map((function(pkg) {
                try {
                    return packageToIntegrationMapping[pkg]();
                } catch (e) {
                    return;
                }
            })).filter((function(p) {
                return p;
            }));
            if (mappedPackages.length > 0) carrier.__SENTRY__.integrations = (0, tslib_es6.__spread)(carrier.__SENTRY__.integrations || [], mappedPackages);
        }
        function addExtensionMethods() {
            _addTracingExtensions();
            if ((0, node.isNodeEnv)()) _autoloadDatabaseIntegrations();
            registerErrorInstrumentation();
        }
    },
    "../shared/node_modules/@sentry/tracing/esm/idletransaction.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            DEFAULT_IDLE_TIMEOUT: () => DEFAULT_IDLE_TIMEOUT,
            IdleTransaction: () => IdleTransaction
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../shared/node_modules/tslib/tslib.es6.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/time.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/env.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/logger.js");
        var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/constants.js");
        var _span__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/span.js");
        var _transaction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/transaction.js");
        var DEFAULT_IDLE_TIMEOUT = 1e3;
        var HEARTBEAT_INTERVAL = 5e3;
        var IdleTransactionSpanRecorder = function(_super) {
            (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(IdleTransactionSpanRecorder, _super);
            function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {
                if (void 0 === transactionSpanId) transactionSpanId = "";
                var _this = _super.call(this, maxlen) || this;
                _this._pushActivity = _pushActivity;
                _this._popActivity = _popActivity;
                _this.transactionSpanId = transactionSpanId;
                return _this;
            }
            IdleTransactionSpanRecorder.prototype.add = function(span) {
                var _this = this;
                if (span.spanId !== this.transactionSpanId) {
                    span.finish = function(endTimestamp) {
                        span.endTimestamp = "number" === typeof endTimestamp ? endTimestamp : (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.timestampWithMs)();
                        _this._popActivity(span.spanId);
                    };
                    if (void 0 === span.endTimestamp) this._pushActivity(span.spanId);
                }
                _super.prototype.add.call(this, span);
            };
            return IdleTransactionSpanRecorder;
        }(_span__WEBPACK_IMPORTED_MODULE_2__.SpanRecorder);
        var IdleTransaction = function(_super) {
            (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(IdleTransaction, _super);
            function IdleTransaction(transactionContext, _idleHub, _idleTimeout, _onScope) {
                if (void 0 === _idleTimeout) _idleTimeout = DEFAULT_IDLE_TIMEOUT;
                if (void 0 === _onScope) _onScope = false;
                var _this = _super.call(this, transactionContext, _idleHub) || this;
                _this._idleHub = _idleHub;
                _this._idleTimeout = _idleTimeout;
                _this._onScope = _onScope;
                _this.activities = {};
                _this._heartbeatCounter = 0;
                _this._finished = false;
                _this._beforeFinishCallbacks = [];
                if (_idleHub && _onScope) {
                    clearActiveTransaction(_idleHub);
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
                    _idleHub.configureScope((function(scope) {
                        return scope.setSpan(_this);
                    }));
                }
                _this._initTimeout = setTimeout((function() {
                    if (!_this._finished) _this.finish();
                }), _this._idleTimeout);
                return _this;
            }
            IdleTransaction.prototype.finish = function(endTimestamp) {
                var e_1, _a;
                var _this = this;
                if (void 0 === endTimestamp) endTimestamp = (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.timestampWithMs)();
                this._finished = true;
                this.activities = {};
                if (this.spanRecorder) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] finishing IdleTransaction", new Date(1e3 * endTimestamp).toISOString(), this.op);
                    try {
                        for (var _b = (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var callback = _c.value;
                            callback(this, endTimestamp);
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                    this.spanRecorder.spans = this.spanRecorder.spans.filter((function(span) {
                        if (span.spanId === _this.spanId) return true;
                        if (!span.endTimestamp) {
                            span.endTimestamp = endTimestamp;
                            span.setStatus("cancelled");
                            (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
                        }
                        var keepSpan = span.startTimestamp < endTimestamp;
                        if (!keepSpan) (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
                        return keepSpan;
                    }));
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] flushing IdleTransaction");
                } else (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] No active IdleTransaction");
                if (this._onScope) clearActiveTransaction(this._idleHub);
                return _super.prototype.finish.call(this, endTimestamp);
            };
            IdleTransaction.prototype.registerBeforeFinishCallback = function(callback) {
                this._beforeFinishCallbacks.push(callback);
            };
            IdleTransaction.prototype.initSpanRecorder = function(maxlen) {
                var _this = this;
                if (!this.spanRecorder) {
                    var pushActivity = function(id) {
                        if (_this._finished) return;
                        _this._pushActivity(id);
                    };
                    var popActivity = function(id) {
                        if (_this._finished) return;
                        _this._popActivity(id);
                    };
                    this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("Starting heartbeat");
                    this._pingHeartbeat();
                }
                this.spanRecorder.add(this);
            };
            IdleTransaction.prototype._pushActivity = function(spanId) {
                if (this._initTimeout) {
                    clearTimeout(this._initTimeout);
                    this._initTimeout = void 0;
                }
                (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] pushActivity: " + spanId);
                this.activities[spanId] = true;
                (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
            };
            IdleTransaction.prototype._popActivity = function(spanId) {
                var _this = this;
                if (this.activities[spanId]) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] popActivity " + spanId);
                    delete this.activities[spanId];
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
                }
                if (0 === Object.keys(this.activities).length) {
                    var timeout = this._idleTimeout;
                    var end_1 = (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.timestampWithMs)() + timeout / 1e3;
                    setTimeout((function() {
                        if (!_this._finished) {
                            _this.setTag(_constants__WEBPACK_IMPORTED_MODULE_5__.FINISH_REASON_TAG, _constants__WEBPACK_IMPORTED_MODULE_5__.IDLE_TRANSACTION_FINISH_REASONS[1]);
                            _this.finish(end_1);
                        }
                    }), timeout);
                }
            };
            IdleTransaction.prototype._beat = function() {
                if (this._finished) return;
                var heartbeatString = Object.keys(this.activities).join("");
                if (heartbeatString === this._prevHeartbeatString) this._heartbeatCounter += 1; else this._heartbeatCounter = 1;
                this._prevHeartbeatString = heartbeatString;
                if (this._heartbeatCounter >= 3) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
                    this.setStatus("deadline_exceeded");
                    this.setTag(_constants__WEBPACK_IMPORTED_MODULE_5__.FINISH_REASON_TAG, _constants__WEBPACK_IMPORTED_MODULE_5__.IDLE_TRANSACTION_FINISH_REASONS[0]);
                    this.finish();
                } else this._pingHeartbeat();
            };
            IdleTransaction.prototype._pingHeartbeat = function() {
                var _this = this;
                (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
                setTimeout((function() {
                    _this._beat();
                }), HEARTBEAT_INTERVAL);
            };
            return IdleTransaction;
        }(_transaction__WEBPACK_IMPORTED_MODULE_6__.Transaction);
        function clearActiveTransaction(hub) {
            if (hub) {
                var scope = hub.getScope();
                if (scope) {
                    var transaction = scope.getTransaction();
                    if (transaction) scope.setSpan(void 0);
                }
            }
        }
    },
    "../shared/node_modules/@sentry/tracing/esm/span.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            SpanRecorder: () => SpanRecorder,
            Span: () => Span
        });
        var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../shared/node_modules/tslib/tslib.es6.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/misc.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/time.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/object.js");
        var SpanRecorder = function() {
            function SpanRecorder(maxlen) {
                if (void 0 === maxlen) maxlen = 1e3;
                this.spans = [];
                this._maxlen = maxlen;
            }
            SpanRecorder.prototype.add = function(span) {
                if (this.spans.length > this._maxlen) span.spanRecorder = void 0; else this.spans.push(span);
            };
            return SpanRecorder;
        }();
        var Span = function() {
            function Span(spanContext) {
                this.traceId = (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_0__.uuid4)();
                this.spanId = (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_0__.uuid4)().substring(16);
                this.startTimestamp = (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.timestampWithMs)();
                this.tags = {};
                this.data = {};
                if (!spanContext) return this;
                if (spanContext.traceId) this.traceId = spanContext.traceId;
                if (spanContext.spanId) this.spanId = spanContext.spanId;
                if (spanContext.parentSpanId) this.parentSpanId = spanContext.parentSpanId;
                if ("sampled" in spanContext) this.sampled = spanContext.sampled;
                if (spanContext.op) this.op = spanContext.op;
                if (spanContext.description) this.description = spanContext.description;
                if (spanContext.data) this.data = spanContext.data;
                if (spanContext.tags) this.tags = spanContext.tags;
                if (spanContext.status) this.status = spanContext.status;
                if (spanContext.startTimestamp) this.startTimestamp = spanContext.startTimestamp;
                if (spanContext.endTimestamp) this.endTimestamp = spanContext.endTimestamp;
            }
            Span.prototype.child = function(spanContext) {
                return this.startChild(spanContext);
            };
            Span.prototype.startChild = function(spanContext) {
                var childSpan = new Span((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, spanContext), {
                    parentSpanId: this.spanId,
                    sampled: this.sampled,
                    traceId: this.traceId
                }));
                childSpan.spanRecorder = this.spanRecorder;
                if (childSpan.spanRecorder) childSpan.spanRecorder.add(childSpan);
                childSpan.transaction = this.transaction;
                return childSpan;
            };
            Span.prototype.setTag = function(key, value) {
                var _a;
                this.tags = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.tags), (_a = {}, 
                _a[key] = value, _a));
                return this;
            };
            Span.prototype.setData = function(key, value) {
                var _a;
                this.data = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.data), (_a = {}, 
                _a[key] = value, _a));
                return this;
            };
            Span.prototype.setStatus = function(value) {
                this.status = value;
                return this;
            };
            Span.prototype.setHttpStatus = function(httpStatus) {
                this.setTag("http.status_code", String(httpStatus));
                var spanStatus = spanStatusfromHttpCode(httpStatus);
                if ("unknown_error" !== spanStatus) this.setStatus(spanStatus);
                return this;
            };
            Span.prototype.isSuccess = function() {
                return "ok" === this.status;
            };
            Span.prototype.finish = function(endTimestamp) {
                this.endTimestamp = "number" === typeof endTimestamp ? endTimestamp : (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.timestampWithMs)();
            };
            Span.prototype.toTraceparent = function() {
                var sampledString = "";
                if (void 0 !== this.sampled) sampledString = this.sampled ? "-1" : "-0";
                return this.traceId + "-" + this.spanId + sampledString;
            };
            Span.prototype.toContext = function() {
                return (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.dropUndefinedKeys)({
                    data: this.data,
                    description: this.description,
                    endTimestamp: this.endTimestamp,
                    op: this.op,
                    parentSpanId: this.parentSpanId,
                    sampled: this.sampled,
                    spanId: this.spanId,
                    startTimestamp: this.startTimestamp,
                    status: this.status,
                    tags: this.tags,
                    traceId: this.traceId
                });
            };
            Span.prototype.updateWithContext = function(spanContext) {
                var _a, _b, _c, _d, _e;
                this.data = (_a = spanContext.data, null !== _a && void 0 !== _a ? _a : {});
                this.description = spanContext.description;
                this.endTimestamp = spanContext.endTimestamp;
                this.op = spanContext.op;
                this.parentSpanId = spanContext.parentSpanId;
                this.sampled = spanContext.sampled;
                this.spanId = (_b = spanContext.spanId, null !== _b && void 0 !== _b ? _b : this.spanId);
                this.startTimestamp = (_c = spanContext.startTimestamp, null !== _c && void 0 !== _c ? _c : this.startTimestamp);
                this.status = spanContext.status;
                this.tags = (_d = spanContext.tags, null !== _d && void 0 !== _d ? _d : {});
                this.traceId = (_e = spanContext.traceId, null !== _e && void 0 !== _e ? _e : this.traceId);
                return this;
            };
            Span.prototype.getTraceContext = function() {
                return (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.dropUndefinedKeys)({
                    data: Object.keys(this.data).length > 0 ? this.data : void 0,
                    description: this.description,
                    op: this.op,
                    parent_span_id: this.parentSpanId,
                    span_id: this.spanId,
                    status: this.status,
                    tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
                    trace_id: this.traceId
                });
            };
            Span.prototype.toJSON = function() {
                return (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.dropUndefinedKeys)({
                    data: Object.keys(this.data).length > 0 ? this.data : void 0,
                    description: this.description,
                    op: this.op,
                    parent_span_id: this.parentSpanId,
                    span_id: this.spanId,
                    start_timestamp: this.startTimestamp,
                    status: this.status,
                    tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
                    timestamp: this.endTimestamp,
                    trace_id: this.traceId
                });
            };
            return Span;
        }();
        function spanStatusfromHttpCode(httpStatus) {
            if (httpStatus < 400 && httpStatus >= 100) return "ok";
            if (httpStatus >= 400 && httpStatus < 500) switch (httpStatus) {
              case 401:
                return "unauthenticated";

              case 403:
                return "permission_denied";

              case 404:
                return "not_found";

              case 409:
                return "already_exists";

              case 413:
                return "failed_precondition";

              case 429:
                return "resource_exhausted";

              default:
                return "invalid_argument";
            }
            if (httpStatus >= 500 && httpStatus < 600) switch (httpStatus) {
              case 501:
                return "unimplemented";

              case 503:
                return "unavailable";

              case 504:
                return "deadline_exceeded";

              default:
                return "internal_error";
            }
            return "unknown_error";
        }
    },
    "../shared/node_modules/@sentry/tracing/esm/transaction.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Transaction: () => Transaction
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../shared/node_modules/tslib/tslib.es6.js");
        var _sentry_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../shared/node_modules/@sentry/hub/esm/hub.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/is.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/env.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/logger.js");
        var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("../shared/node_modules/@sentry/utils/esm/object.js");
        var _span__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../shared/node_modules/@sentry/tracing/esm/span.js");
        var Transaction = function(_super) {
            (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Transaction, _super);
            function Transaction(transactionContext, hub) {
                var _this = _super.call(this, transactionContext) || this;
                _this._measurements = {};
                _this._hub = (0, _sentry_hub__WEBPACK_IMPORTED_MODULE_1__.getCurrentHub)();
                if ((0, _sentry_utils__WEBPACK_IMPORTED_MODULE_2__.isInstanceOf)(hub, _sentry_hub__WEBPACK_IMPORTED_MODULE_1__.Hub)) _this._hub = hub;
                _this.name = transactionContext.name || "";
                _this.metadata = transactionContext.metadata || {};
                _this._trimEnd = transactionContext.trimEnd;
                _this.transaction = _this;
                return _this;
            }
            Transaction.prototype.setName = function(name) {
                this.name = name;
            };
            Transaction.prototype.initSpanRecorder = function(maxlen) {
                if (void 0 === maxlen) maxlen = 1e3;
                if (!this.spanRecorder) this.spanRecorder = new _span__WEBPACK_IMPORTED_MODULE_3__.SpanRecorder(maxlen);
                this.spanRecorder.add(this);
            };
            Transaction.prototype.setMeasurements = function(measurements) {
                this._measurements = (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, measurements);
            };
            Transaction.prototype.setMetadata = function(newMetadata) {
                this.metadata = (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, this.metadata), newMetadata);
            };
            Transaction.prototype.finish = function(endTimestamp) {
                var _this = this;
                if (void 0 !== this.endTimestamp) return;
                if (!this.name) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
                    this.name = "<unlabeled transaction>";
                }
                _super.prototype.finish.call(this, endTimestamp);
                if (true !== this.sampled) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
                    var client = this._hub.getClient();
                    var transport = client && client.getTransport && client.getTransport();
                    if (transport && transport.recordLostEvent) transport.recordLostEvent("sample_rate", "transaction");
                    return;
                }
                var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter((function(s) {
                    return s !== _this && s.endTimestamp;
                })) : [];
                if (this._trimEnd && finishedSpans.length > 0) this.endTimestamp = finishedSpans.reduce((function(prev, current) {
                    if (prev.endTimestamp && current.endTimestamp) return prev.endTimestamp > current.endTimestamp ? prev : current;
                    return prev;
                })).endTimestamp;
                var transaction = {
                    contexts: {
                        trace: this.getTraceContext()
                    },
                    spans: finishedSpans,
                    start_timestamp: this.startTimestamp,
                    tags: this.tags,
                    timestamp: this.endTimestamp,
                    transaction: this.name,
                    type: "transaction",
                    sdkProcessingMetadata: this.metadata
                };
                var hasMeasurements = Object.keys(this._measurements).length > 0;
                if (hasMeasurements) {
                    (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
                    transaction.measurements = this._measurements;
                }
                (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_4__.isDebugBuild)() && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
                return this._hub.captureEvent(transaction);
            };
            Transaction.prototype.toContext = function() {
                var spanContext = _super.prototype.toContext.call(this);
                return (0, _sentry_utils__WEBPACK_IMPORTED_MODULE_6__.dropUndefinedKeys)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, 
                tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, spanContext), {
                    name: this.name,
                    trimEnd: this._trimEnd
                }));
            };
            Transaction.prototype.updateWithContext = function(transactionContext) {
                var _a;
                _super.prototype.updateWithContext.call(this, transactionContext);
                this.name = (_a = transactionContext.name, null !== _a && void 0 !== _a ? _a : "");
                this._trimEnd = transactionContext.trimEnd;
                return this;
            };
            return Transaction;
        }(_span__WEBPACK_IMPORTED_MODULE_3__.Span);
    },
    "../shared/node_modules/@sentry/tracing/esm/utils.js": (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            hasTracingEnabled: () => hasTracingEnabled,
            getActiveTransaction: () => getActiveTransaction,
            msToSec: () => msToSec,
            secToMs: () => secToMs
        });
        var _sentry_hub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../shared/node_modules/@sentry/hub/esm/hub.js");
        function hasTracingEnabled(maybeOptions) {
            var client = (0, _sentry_hub__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().getClient();
            var options = maybeOptions || client && client.getOptions();
            return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
        }
        function getActiveTransaction(maybeHub) {
            var hub = maybeHub || (0, _sentry_hub__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)();
            var scope = hub.getScope();
            return scope && scope.getTransaction();
        }
        function msToSec(time) {
            return time / 1e3;
        }
        function secToMs(time) {
            return 1e3 * time;
        }
    },
    "../shared/node_modules/core-js/modules/es.number.is-nan.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
        var $ = __webpack_require__("../shared/node_modules/core-js/internals/export.js");
        $({
            target: "Number",
            stat: true
        }, {
            isNaN: function(number) {
                return number != number;
            }
        });
    },
    "../shared/node_modules/core-js/modules/es.string.match.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        var call = __webpack_require__("../shared/node_modules/core-js/internals/function-call.js");
        var fixRegExpWellKnownSymbolLogic = __webpack_require__("../shared/node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
        var anObject = __webpack_require__("../shared/node_modules/core-js/internals/an-object.js");
        var toLength = __webpack_require__("../shared/node_modules/core-js/internals/to-length.js");
        var toString = __webpack_require__("../shared/node_modules/core-js/internals/to-string.js");
        var requireObjectCoercible = __webpack_require__("../shared/node_modules/core-js/internals/require-object-coercible.js");
        var getMethod = __webpack_require__("../shared/node_modules/core-js/internals/get-method.js");
        var advanceStringIndex = __webpack_require__("../shared/node_modules/core-js/internals/advance-string-index.js");
        var regExpExec = __webpack_require__("../shared/node_modules/core-js/internals/regexp-exec-abstract.js");
        fixRegExpWellKnownSymbolLogic("match", (function(MATCH, nativeMatch, maybeCallNative) {
            return [ function(regexp) {
                var O = requireObjectCoercible(this);
                var matcher = void 0 == regexp ? void 0 : getMethod(regexp, MATCH);
                return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
            }, function(string) {
                var rx = anObject(this);
                var S = toString(string);
                var res = maybeCallNative(nativeMatch, rx, S);
                if (res.done) return res.value;
                if (!rx.global) return regExpExec(rx, S);
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
                var A = [];
                var n = 0;
                var result;
                while (null !== (result = regExpExec(rx, S))) {
                    var matchStr = toString(result[0]);
                    A[n] = matchStr;
                    if ("" === matchStr) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                    n++;
                }
                return 0 === n ? null : A;
            } ];
        }));
    }
}, __webpack_require__ => {
    var __webpack_exec__ = moduleId => __webpack_require__(__webpack_require__.s = moduleId);
    __webpack_exec__("../shared/browser/utils/sentry.js"), __webpack_exec__("./src/assets/proofing/main.js");
} ]);